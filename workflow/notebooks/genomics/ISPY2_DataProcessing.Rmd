---
title: "Brain_Discovery"
subtitle: "[EcoTyper_Project, Data processing](https://github.com/bhklab/PredictIO_EcoTyper)"
author: "Nasim Bondar Sahebi"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: 
  rmdformats::readthedown:
    toc_depth: 4
    theme: lumen
    highlight: espresso
    code_folding: show
    params:
      palette: "npg"
      size: 1
      showlabels: false
      ellipse: true
    css: "styles/custom.css"
    link-citations: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
```

## Overview

This Script **processes and prepares** the **I-SPY2 dataset**, focusing on:
- **Cleaning, merging, and structuring** genomics and radiomics clinical data.
- **Identifying common patients** between datasets.
- **Ensuring MRI segmentation consistency** for further analysis.

### Dataset Summary
- **Study Reference**: [PMID: 35623341](https://pubmed.ncbi.nlm.nih.gov/35623341/)  
- **Clinical Trial**: [ISPY2/NCT01042379](https://clinicaltrials.gov/study/NCT01042379)  
- **Data Source**: [GEO: GSE194040](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE194040)  
- **Study Population**:  
  - **Genomics Data**: 987 patients (mRNA & RPPA profiling)  
  - **Radiomics Data**: 985 patients (MRI scans)  
- **Platforms Used**:
  - **Genomics**: Agilent 44K arrays  
  - **Radiomics**: MRI (DCE-MRI)   

### Patient and Treatment Details
- **Total Patients (RNA-seq)**: 987  
- **Total Patients (MRI)**: 985 (719 I-SPY2 cases, 266 ACRIN-6698 cases)  
- **Treatment Groups**:
  - **IO + Chemo**: 69 patients  
  - **Chemo + Targeted Therapy**: 687 patients  
  - **Chemo Alone**: 179 patients  
  - **Targeted Therapy Alone**: 52 patients  
- **Key Treatment Arms**:
  - Paclitaxel Â± Trastuzumab  
  - Veliparib + Carboplatin  
  - AMG-386 (Trebananib) Â± Trastuzumab  
  - Neratinib, Ganetespib, Ganitumab, Pembrolizumab, Pertuzumab, T-DM1  
  
#### Treatment Arms
- **Chemotherapy Â± IO**  
  - Paclitaxel Â± Trastuzumab  
  - Veliparib + Carboplatin  
- **Targeted Therapies**  
  - AMG-386 (Trebananib) Â± Trastuzumab  
  - Neratinib, Ganetespib, Ganitumab, Pembrolizumab, Pertuzumab, T-DM1
  
### Additional Information
- **Batch Correction**:  
  - **ComBat** was applied to correct batch effects in gene expression data.  
  - Adjusted ~800 patients; linear adjustments applied to remaining cases.  

- **Radiomics Data**:  
  - MRI dataset includes **4 serial DCE-MRI scans per patient**.  
  - Performed **before and during neoadjuvant chemotherapy** to track tumor volume changes and response.  

- **Data Availability**:  
  - ðŸ“‚ **Genomics**: Available in [GEO: GSE194040](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE194040).  
  - ðŸ“‚ **Imaging**: MRI datasets accessible via [The Cancer Imaging Archive (ISPY2 Collection)](https://www.cancerimagingarchive.net/collection/ispy2/).  

- **Key Reference**:  
  - Wolf DM et al., *Cancer Cell*, 2022. [PMID: 35623341](https://pubmed.ncbi.nlm.nih.gov/35623341).  

---

## Section 1: Data Processing Steps

### Load Required Libraries
 
```{r libraries,include=TRUE,message=FALSE,warning=FALSE}
library(here)
library(MultiAssayExperiment) 
library(knitr)
library(readxl)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggvenn)
library(kableExtra) 
library(limma)
library(limma)
library(EnhancedVolcano)
library(msigdbr)
library(fgsea)
```

### Load & Extract Data {.tabset .tabset-pills}

Load MultiAssayExperiment `.rds` File**
This step extracts **clinical, expression(Microarray quantile normalizated), and annotation data** for further analysis.

```{r load multiassay and extract Data}
# Define base directory.
input_dir <- file.path(here(), "data/rawdata/genomics")
output_dir <- file.path(here(), "data/results/genomics")

# Load dataset
mae <- readRDS(file.path(input_dir, "ICB_Wolf.rds"))

# Extract clinical, expression, and annotation data
clin <- data.frame(colData(mae))  
expr <- assays(mae)[["expr"]] # dim 18348 x 987
annot <- data.frame(rowData(mae@ExperimentList$expr))

# Create a named vector to map gene_id to gene_name
gene_map <- setNames(annot$gene_name, annot$gene_id)
rownames(expr) <- gene_map[rownames(expr)]
rownames(annot) <- annot$gene_name
```

#### Clinical Data 

Display first 50 rows of  Clinical Data.

```{r clin summery}
# Display clin 
kable(head(clin,50), caption = "Genomics Clinical Data") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
```

#### Microarray Expression Data 

Display first 20 rows of  quantile-normalized Microarray data

```{r expr summery}
# Display the first 20 rows 
kable(head(expr, 20), caption = "Expression Data-Microarray") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
```

#### Annotation Data 

Displays gene annotation for the dataset.

```{r data summery}
# Display the first 20 rows 
kable(head(annot, 20), caption = "Gene Annotation Data") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
```

### Match Patients: Genomics & Radiomics Integration

This section identifies overlapping patients between genomics (gene expression) and radiomics (MRI scans) datasets.

#### Step 1: Load Radiomics Metadata

The radiomics dataset contains dynamic contrast-enhanced MRI **(DCE-MRI)** scans used to monitor tumor response to treatment.  

**Metadata Source:**  
- **File:** `ISPY2-Imaging-Cohort-1-Clinical-Data.xlsx`  
- **Access:** [The Cancer Imaging Archive - I-SPY2 Collection](https://www.cancerimagingarchive.net/collection/ispy2/)  
- **Total Patients:** **985**  
  - **719** I-SPY2 cases  
  - **266** [ACRIN-6698 cases](https://www.cancerimagingarchive.net/collection/ispy1/)  

```{r Load Radiomics Metadata}
# Load radiomics clinical data
Radiomics_clin <- read_excel(file.path(input_dir, "ISPY2-Imaging-Cohort-1-Clinical-Data.xlsx"))  

# Display radiomics metadata with scrolling
kable(Radiomics_clin, caption = "Radiomics Clinical Data") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
```

#### Step 2: Summary of Radiomics Data

- **Each patient has 4 MRI scans (T1-T4)**
- **MRI features include:**
  - Functional Tumor Volume (FTV)
  - Longest Tumor Diameter
  - Sphericity  
- **Data collected from 22+ clinical centers**   

#### Step 3: Identify Common Patients

To integrate genomics and radiomics data, we **match patient IDs** across datasets.

```{r check Patient Matching}
# Prepare genomic clinical data
Genomics_clin <- clin  
Genomics_clin$patientid <- sub("^X", "", Genomics_clin$patientid)  # Remove "X" prefix
rownames(Genomics_clin) <- Genomics_clin$patientid
colnames(expr) <- sub("^X", "", colnames(expr))

# Identify common patients
common_patients <- intersect(Genomics_clin$patientid, Radiomics_clin$Patient_ID)  

# Print count of common patients
cat("Patients with both microarray and MRI data:", length(common_patients), "\n")
```

#### Step 4: Visualize Patient Overlap

A Venn diagram illustrates genomics vs
. radiomics patient overlap.

```{r visualize patient overlap}
# Create Venn diagram
venn_data <- list(Genomics = Genomics_clin$patientid, Radiomics = Radiomics_clin$Patient_ID)

ggvenn(venn_data, fill_color = c("#A6CEE3", "#FB9A99"), stroke_size = 0.5, set_name_size = 4) +
  ggtitle("Overlap of Genomics (Microarray) and Radiomics (MRI) Patient IDs") +
  theme(plot.title = element_text(hjust = 0.5, size = 12, face = "bold"), plot.background = element_rect(fill = "white"), panel.background = element_blank())
```

### Merge Genomics & Radiomics Data

Merging both datasets based on **common patient IDs**.

**Adjustments:** 

- **Prefix MRI columns with `"Radiomics_"`**  
- **Ensure consistent patient IDs**  
- **Save merged dataset for analysis**  
 
```{r Merge}
# Add prefix to radiomics columns
colnames(Radiomics_clin)[-which(colnames(Radiomics_clin) == "Patient_ID")] <- paste0("Radiomics_", colnames(Radiomics_clin)[-which(colnames(Radiomics_clin) == "Patient_ID")])

# Merge datasets
merged_clin <- merge(Genomics_clin, Radiomics_clin, by.x = "patientid", by.y = "Patient_ID")

# Sort by patient ID
merged_clin <- merged_clin[order(merged_clin$patientid), ]

# Display merged dataset with scrolling
kable(head(merged_clin,50), caption = "Merged Clinical Data (Genomics & Radiomics)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

# Save dataset as CSV
write.csv(merged_clin, file = file.path(output_dir, "combined_clin_radiogenomic.csv"), row.names = FALSE)

```


### Segmentation Consistency Check

We checked segmentation consistency by verifying whether each patient had four **DCE-MRI** segmentation masks, as required for accurate **Functional Tumor Volume (FTV)** analysis. Most patients met this, but some had fewer and were flagged for review.

### Segmentation Process in DCE-MRI

Each scan undergoes multiple segmentation steps:  
1. **Manual VOI (Volume of Interest):** A rectangular region around the enhancing tumor.  
2. **Background Masking:** Removes noise and fat saturation artifacts.  
3. **Percent Enhancement (PE) Threshold:** Filters non-enhancing tissue.  
4. **Connectivity Filter:** Ensures 3D tumor voxel connectivity.  
5. **OMIT Regions:** Manual exclusion of non-tumor areas.  

**Segmentation masks are stored as 2D DICOM images** aligned with the original **DCE MRI scans**.  
note: **Download masks from UCSF Box:** [Link](https://ucsf.box.com/s/d09xetaatzgnz2p9bxlqh50rrzilgcoj)  

### Segmentation Metadata {.tabset .tabset-pills}

#### ISPY1: MRI Series Metadata  
**Metadata for ISPY1** is stored in `ispy1_dce_series_info.xlsx`, containing data for **221 patients**. This dataset includes MRI series metadata for each patient, covering:  

- **Patient ID & Time Point (T1â€“T4)**  
- **MRI Series Description & Unique ID**  
- **Signal Enhancement Ratio (SER) Calculation Indicator**  
- **OMIT Region Counts (Non-Tumor Exclusion)**   

```{r ISPY1 segmentation metadata}
# Load ISPY1 segmentation metadata
ispy1_dce_series_info <- read_excel(
  path = file.path(input_dir, "ispy1_dce_series_info.xlsx"), 
  sheet = "DCE Series, All 20160823"
) 

# Display ISPY1 segmentation metadata
kable(head(ispy1_dce_series_info, 20), caption = "DCE MRI Series Information") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
```

#### ISPY2: MRI Series Metadata  

Metadata for ISPY2 was extracted from `series-data1741883133411.csv`, containing data for **719 patients**. This dataset includes MRI series metadata for each patient, covering:  

- **Subject ID**  
- **Study Description** (e.g., `"ISPY2_MRI_T0"`)  
- **Number of Images**  
- **Modality** (e.g., `"MR"`, `"SEG"`)  

```{r segmentation metadata}
# Load ISPY2 segmentation metadata
ispy2_dce_series_info <- read.csv(file.path(input_dir, "series-data1741883133411.csv"))

# Rename the "ispy2_dce_series_info" column to "PATIENT_ID"
colnames(ispy2_dce_series_info)[colnames(ispy2_dce_series_info) == "Subject.ID" ] <- "PATIENT_ID"

# Extract time points from the "Study.Description" column
ispy2_dce_series_info$TIME_POINT <- gsub(".*(T[0-9]+).*", "\\1", ispy2_dce_series_info$Study.Description)

# Display ISPY2 segmentation metadata
kable(head(ispy2_dce_series_info, 20), caption = "ISPY2 DCE MRI Series Information") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

# Select only PATIENT_ID and TIME_POINT columns from both datasets
ispy1_selected <- ispy1_dce_series_info[, c("PATIENT_ID", "TIME_POINT")]
ispy2_selected <- ispy2_dce_series_info[, c("PATIENT_ID", "TIME_POINT")]

# Merge based on PATIENT_ID and TIME_POINT
ispy1and2 <- merge(ispy1_selected, ispy2_selected, by = c("PATIENT_ID", "TIME_POINT"), all = TRUE)
```

### Check Segmentation Consistency Across Time Points (T1-T4)  

Each of the 940 patients is expected to have at least four segmentation masks, one for each of their four MRI scans

```{r Check Segmentation}
# Count segmentations per patient for each time point
series_per_patient <- ispy1and2 %>%
  group_by(PATIENT_ID, TIME_POINT) %>%
  summarize(Series_Count = n(), .groups = 'drop') %>%
  pivot_wider(names_from = TIME_POINT, values_from = Series_Count, values_fill = 0) %>%
  mutate(across(starts_with("T"), as.numeric),
         Total_Segmentations = rowSums(select(., starts_with("T")), na.rm = TRUE))

# Display segmentation counts per patient
kable(series_per_patient, caption = "Segmentation Counts per Patient") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
```

### Patients with Missing Segmentations

Patients missing **one or more segmentation masks** need further review (24 patients).

```{r missing segmentations}
# Identify patients with <4 segmentations
patients_less_than_4 <- series_per_patient %>%
  filter(Total_Segmentations < 4) %>%
  select(PATIENT_ID, Total_Segmentations)

# Display patients missing segmentations
kable(patients_less_than_4, caption = "Patients with Less Than 4 Segmentation Masks") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
```

---

## Section 2: Genomic Analysis

**Objective:** Process microarray expression data to identify predictive and biologically meaningful features associated with treatment response.

### 1. Subset to Radiogenomic Cohort

* Matched clinical, microarray expression, and MRI data
* Final dataset: **982 patients Ã— 18,348 genes**

```{r subset to Radiogenomics}
# 1. Subset to common patients
expr_data <- expr[, common_patients] #982
annot_data <- annot[annot$gene_name %in% common_patients , ]
clin_data <- merged_clin[merged_clin$patientid %in% common_patients, ]
```

### 2. Restrict to Protein-Coding Genes

* Retained only **protein-coding genes** based on **GENCODE annotations**
** Genes:** 17,547
* *Optional:* Apply variance filtering to remove low-variance genes

```{r restrict to preotein-coding genes}
# 1. Subset to common patients
expr_data <- expr[, common_patients] #982
annot_data <- annot[annot$gene_name %in% common_patients , ]
clin_data <- merged_clin[merged_clin$patientid %in% common_patients, ]

# 2. Restrict to Protein-Coding Genes.
annot_proteincoding <- annot[annot$gene_type == "protein_coding",] # 17547 protein coding genes.
expr_data <- expr_data[rownames(expr_data) %in% rownames(annot_proteincoding),]

# TODO: optional low varience removal
# plot a density plot
plot(
  density(as.numeric(as.matrix(expr_data)), na.rm = TRUE),
  main = "Overall Expression Density",
  xlab = "Expression",
  ylab = "Density"
)

# Frequency table for the treatment columns
DT::datatable(as.data.frame(table(merged_clin$treatment)), 
              colnames = c("Treatment", "Count"))
DT::datatable(as.data.frame(table(merged_clin$treatmentid)), 
              colnames = c("Treatment ID", "Count"))

#TODO:  vaitaion per treatment plots
```

### 3. PredictIO RNA Signature Integration

* Loaded **55 curated immune-oncology (IO) RNA signatures** (`.rda` format)
* Each signature derived from **peer-reviewed publications**
* Signatures used to assess **immune response**, **sensitivity**, or **resistance** to immune checkpoint blockade
* Mapped to **GENCODE v40**
* Sources:
  * GitHub: [bhklab/SignatureSets](https://github.com/bhklab/SignatureSets)
  * Web app: [predictio.ca](https://predictio.ca/)

```{r PredictIO sigs intersection}
# 3. check of how many genes are avaivale in Predio_signitures
sig_path <- file.path(input_dir, "predictIO_sigs")
rda_files <- list.files(sig_path, pattern = "\\.rda$", full.names = TRUE)
summary_list <- list()

# Check gene overlap between IO signatures and expression data
for (file in rda_files) {
  sig_obj <- get(load(file))
  sig_name <- if ("signature_name" %in% colnames(sig_obj) && length(unique(sig_obj$signature_name)) > 0)
    unique(sig_obj$signature_name)[1]
  else
    tools::file_path_sans_ext(basename(file))

  if (!"gene_name" %in% colnames(sig_obj)) next

  genes <- sig_obj$gene_name
  matched <- intersect(rownames(expr_data), genes)

  summary_list[[sig_name]] <- data.frame(
    signature = sig_name,
    n_genes_total = length(genes),
    n_genes_matched = length(matched),
    matched_genes = paste(sort(matched), collapse = ", ")
  )
}

summary_df <- do.call(rbind, summary_list)

kable(summary_df, caption = "Summary of gene overlap between IO signatures and expression data") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

#TODO: 
# - IO: known sig ( eg.50 RNA): start with subset of sig 
# - chemo: two ways (low varience removal) 1. already publish sig for breast  2.MSIGDB( extract pathways)-GO-Reactom?: 80% cuoff , act like  sig example. GSVEA compute scores.
# filteration by correlations base don thier scores.then smaller pathways. 

# next steps: slected pathways with radiomcs features. 
```

### 4. Differential Gene Expression Analysis (R vs NR) {.tabset .tabset-pills}

* **Method:** `limma` package in R
* **Comparison:** **Responders (R)** vs **Non-Responders (NR)**
* **Adjustment:** Benjamini-Hochberg FDR correction
* **Output:** `Limma_Fit.txt`
* **Visualization:** Volcano plots showing log2 fold change vs â€“log10 adjusted p-value
* **Total DE Genes Identified:** 5,870

#### Full dataset analysis (no subsetting)

```{r DEG- Full dataset analysis,fig.width=7, fig.height=7}
cat("### Full dataset analysis (no subsetting)\n")

# Design and model
design_full <- model.matrix(~ clin_data$response)
fit_full <- eBayes(lmFit(expr_data, design_full))
top_full <- topTable(fit_full, sort.by = "P", n = Inf)
top_full$Gene <- rownames(top_full)

# Save results
write.table(top_full, file.path(output_dir,"DEG_analysis", "full_limma_fit.txt"),
            sep = "\t", quote = FALSE, row.names = FALSE)

# Display table
DT::datatable(round(top_full[sapply(top_full, is.numeric)], 3), 
              caption = "TopTable - Full")


# Volcano plot
top_clean <- top_full[, sapply(top_full, is.numeric)]
rownames(top_clean) <- top_full$Gene
  print(EnhancedVolcano(top_full,
    lab = rownames(top_full),
    x = 'logFC',
    y = 'P.Value',
    pCutoff = 0.05,
    FCcutoff = 1.5,
    xlim = c(-3, 3),
    ylim = c(0, 20),
    title = paste("Volcano Plot (P value)")
  ))

  # Volcano plot: FDR
  print(EnhancedVolcano(top_full,
    lab = rownames(top_full),
    x = 'logFC',
    y = 'adj.P.Val',
    pCutoff = 0.05,
    FCcutoff = 1.5,
    xlim = c(-3, 3),
    ylim = c(0, 20),
    legendLabels = c('Not sig.', 'Log FC', 'adj p-value', 'adj p-value & Log FC'),
    title = paste("Volcano Plot (FDR) ")
  ))

# Summary
sig_genes_full <- rownames(top_full)[top_full$adj.P.Val < 0.05 & abs(top_full$logFC) >= 1.5]
cat("DE genes (adj.P.Val < 0.05):", sum(top_full$adj.P.Val < 0.05), "\n")
cat("DE genes (adj.P.Val < 0.05 & abs(logFC) â‰¥ 1.5):", length(sig_genes_full), "\n")
cat(" No Significant gene names:\n")
print(sig_genes_full)
```

#### Subgroup Analysis by Treatment Type 

Treatment groups: `"chemo"`, `"chemo+targeted"`, `"IO+chemo"`, `"targeted"`

**Summary of Differentially Expressed Genes by Treatment**

| **Treatment**           | **FDR < 0.05** | **FDR < 0.05 & High FC** | **Significant Genes (`|logâ‚‚FC| â‰¥ 1.5`)**                                                                                                  |
|-------------------------|----------------|---------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|
| Chemo                   | 0              | 0                         | â€“                                                                                                                                         |
| Chemo + Targeted        | 4,152          | 1                         | AGR3                                                                                                                                    |
| IO + Chemo              | 521            | 47                        | CA12, SLC7A2, LAMP3, CCDC74B, CCL13, ACOX2, AGR2, SCUBE2, GDF15, CRABP1, TNNT1, ELF5, ANXA9, AGR3, ROPN1, IDO1, FOXA1, PROM1, TFF1, TFF3, DYNLRB2, CHI3L1, DNALI1, FSIP1, DHRS2, CLSTN2, EEF1A2, CHI3L2, KRT23, GABRP, CXCL13, GSTA5, MSMB, ROPN1B, KRT5, MARCO, NAT1, CXCL9, STMND1, PPP1R14C, UBD, AR, VGLL1, KRT15, GATA3, PDZK1, MIA |
| Targeted                | 5              | 3                         | GRB7, MNX1, PNMT                                                                                                                          |

```{r DEG- subset dataset analysis,fig.width=7, fig.height=7}
# Frequency table for the treatment columns
DT::datatable(as.data.frame(table(merged_clin$treatment)), 
              colnames = c("Treatment", "Count"))
DT::datatable(as.data.frame(table(merged_clin$treatmentid)), 
              colnames = c("Treatment ID", "Count"))

treatment_list <- c("chemo", "chemo+targeted", "IO+chemo", "targeted")
sig_gene_list <- list()
top_table_list <- list()

for (treatment in treatment_list) {
  cat("\nProcessing:", treatment, "\n")
  
  # Subset data
  clin_sub <- clin_data[clin_data$treatment == treatment, ]
  matched_ids <- clin_sub$patientid[clin_sub$patientid %in% colnames(expr_data)]
  expr_sub <- expr_data[, matched_ids]

  # Design and fit
  design <- model.matrix(~ clin_sub$response)
  fit <- lmFit(expr_sub, design)
  fit <- eBayes(fit)
  top.table <- topTable(fit, sort.by = "P", n = Inf)

  # Count DE genes (adj.P.Val)
  cat("DE genes (adj.P.Val < 0.05):", sum(top.table$adj.P.Val < 0.05), "\n")

  # Prepare for plotting (remove non-numeric cols)
  top.table.clean <- top.table[, sapply(top.table, is.numeric)]
  rownames(top.table.clean) <- rownames(top.table)

  # Volcano plot: P-value
  print(EnhancedVolcano(top.table.clean,
    lab = rownames(top.table.clean),
    x = 'logFC',
    y = 'P.Value',
    pCutoff = 0.05,
    FCcutoff = 1.5,
    xlim = c(-5, 5),
    ylim = c(0, 8),
    title = paste("Volcano Plot (P value) -", treatment)
  ))

  # Volcano plot: FDR
  print(EnhancedVolcano(top.table.clean,
    lab = rownames(top.table.clean),
    x = 'logFC',
    y = 'adj.P.Val',
    pCutoff = 0.05,
    FCcutoff = 1.5,
    xlim = c(-5, 5),
    ylim = c(0, 8),
    legendLabels = c('Not sig.', 'Log FC', 'adj p-value', 'adj p-value & Log FC'),
    title = paste("Volcano Plot (FDR) -", treatment)
  ))

  # Save top table
  top.table$Gene <- rownames(top.table)
  file_name <- paste0(gsub("\\+", "_", treatment), "_limma_fit.txt")
  write.table(top.table, file = file.path(output_dir,"DEG_analysis", file_name),
              row.names = FALSE, sep = "\t", quote = FALSE)

  # Show datatable
  top.display <- top.table
  top.display[, sapply(top.display, is.numeric)] <- round(top.display[, sapply(top.display, is.numeric)], 3)
  print(DT::datatable(top.display, caption = paste("TopTable -", treatment)))

  # Significant gene names
  sig_genes <- rownames(top.table)[top.table$adj.P.Val < 0.05 & abs(top.table$logFC) >= 1.5]
  cat("DE genes (adj.P.Val < 0.05 & abs(logFC) â‰¥ 1.5):", length(sig_genes), "\n")
  cat("Significant gene names:\n")

  # Store in a named list
  top_table_list[[treatment]] <- top.table
  sig_gene_list[[treatment]] <- sig_genes
  print(sig_genes)

  # Optionally save gene list
  gene_file <- paste0(gsub("\\+", "_", treatment), "_significant_genes.txt")
  writeLines(sig_genes, file.path(output_dir,"DEG_analysis", gene_file))
}
```

### 5. Pathway Enrichment Analysis {.tabset .tabset-pills}

**a. MSigDB Hallmark Pathways** 

* Gene sets downloaded from [MSigDB](https://www.gsea-msigdb.org/gsea/msigdb/human/collections.jsp#H)
* Analysis: **GSEA using the `fgsea` R package**
* Input: ranked gene list from differential expression results

**b. KEGG Pathway Analysis (Legacy + Medicus)**
# TODO: use the large rone

* Used both **KEGG\_LEGACY** and **KEGG\_MEDICUS** gene sets
* Significance cutoff for visualization: **FDR < 0.05**
* Output: full results in tab-delimited `.txt` files

#### Full Dataset Enrichment Results 

##### Hallmark Gene Sets

```{r pathway analysis,fig.width=7, fig.height=7}

#TODO: 
# - IO: known sig ( eg.50 RNA): start with subset of sig 
# - chemo: two ways (low varience removal) 1. already publish sig for breast 
# 2.MSIGDB( extract pathways)-GO-Reactom?: 80% cuoff , act like  sig example. GSVEA compute scores.
# filteration by correlations base don thier scores.then smaller pathways. 

# next steps: slected pathways with radiomcs features.
#starting unsupervsised so skip DE analaysis

# Load human hallmark gene sets from MSigDB
pathwaysDF <- msigdbr("Homo sapiens", category="H")

# Create a list of gene symbols for each pathway
pathwaysH <- split(as.character(pathwaysDF$gene_symbol), pathwaysDF$gs_name)

# 1. Create ranks

# Create 'ranks' vector from 'top.table' with logFC as values and gene names as names.
ranks <- top_full$logFC
names(ranks) <- top_full$Gene
ranks <- sort(ranks, decreasing = T)

# Preview the data table of ranks.
kable(ranks) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")
# 2. Bar Plot
# Display the ranked fold changes.
#barplot(ranks)

# 3. Conduct analysis
# Run fgsea with 'pathwaysH' and 'ranks'.
fgseaRes <- fgsea(pathwaysH, ranks)
fgseaRes <- na.omit(fgseaRes)

fgseaResTidy <- fgseaRes %>%
  as_tibble() %>%
  arrange(desc(NES)) #order by NES

# Combine genes in leadingEdge with semicolons
fgseaResTidy$leadingEdge <- sapply(fgseaResTidy$leadingEdge, paste, collapse = ";")
fgseaResTidy <- fgseaResTidy[order(fgseaResTidy$padj), ]

# Show in a Tidy table.
kable(fgseaResTidy) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

# Save fgseaRes as txt file.
write.table(fgseaResTidy, file.path(output_dir,"pathway_analysis","full_fgseaRes_HRank.txt"), sep = "\t", row.names = FALSE, quote = FALSE)

# Mark "significant" if adjusted p-value <= 0.05, else "non-significant".
fgseaResTidy$adjPvalue <- ifelse(fgseaResTidy$padj <= 0.05, "significant", "non-significant")

# Define colors for significance: grey for non-significant and red for significant results.
cols <- c("non-significant" = "grey", "significant" = "red")

# Using ggplot: reorder pathways by NES, fill bars based on significance, flip coordinates for readability.
ggplot(fgseaResTidy, aes(reorder(pathway, NES), NES, fill = adjPvalue)) + geom_col() +
    scale_fill_manual(values = cols) + coord_flip() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    labs(x = "Pathway", y = "Normalized Enrichment Score", title = "Hallmark pathways NES
         Enrichment Score from GSEA")

# 4. GSEA Results Table Plot.
# Plot GSEA table for significant pathways (padj < 0.05) using a GSEA parameter of 0.5.
plotGseaTable(pathwaysH[fgseaRes$pathway[fgseaRes$padj < 0.05]], ranks, fgseaRes, gseaParam=0.5)

# 5.  Enrichment score plot.
# For significant pathways # 14 pathways.

# Store the list of significant pathways (padj < 0.05).
significant_pathways <- fgseaRes$pathway[fgseaRes$padj < 0.05]
# Use a for loop to iterate and plot enrichment for each significant pathway
# for (i in significant_pathways) {
#   enrichment_plot <- plotEnrichment(pathwaysH[[i]], ranks)
#   enrichment_plot <- enrichment_plot + ggtitle(paste("Enrichment Plot for Pathway:",i))
#   print(enrichment_plot)
# }

# Plot significant pathways as points with a gradient color based on p-value and size based on a 'size' variable.
ggplot(fgseaResTidy[fgseaResTidy$padj < 0.05, ], aes(y=reorder(pathway, size),x= NES)) + geom_point(aes(color=padj,size=size)) + 
  scale_color_gradientn(colours = c("red","blue")) + 
  labs(x='Normalized Enrichment Score', y=NULL ) + 
  theme( axis.title = element_text(face='bold'), axis.text = element_text (face='bold') )

# summeay 
# IO_combo: 1.low expression
# 2.a.pathway analaysis (Hallmark _ KEGG _raectom ( + PrediIO sig only forIO)), using copelete ---> 
# 2.b. compute sig score ( rows: pathways-columns:scores): using predio functions- base don sig_info.(adjust csv)
# cut off 80. 
# 3. Correlation sigs_ sig hallmark with kegg_ if more that 90% incomommn rmeove theem.rmeove duplications
# for all pathways. --> rmeove highly corrolated.
# 4. correlation genomics and radiomics feature(subset by matching treatment, less scale of radiomics features).

```

##### KEGG Pathway Analysis {.tabset .tabset-pills}

To do KEGG pathway analysis, both KEGG_MEDICUS and KEGG_LEGACY are downloaded. The cutoff of 0.05 is applied for visualization, while the text files include the results across all gene sets.

###### KEGG_MEDICUS

```{r pathway analysis dotplot, fig.width=16, fig.height=10}
#Load KEGG_MEDICUS pathways.
pathwaysKEGG_MED <- gmtPathways(file.path(input_dir, "c2.cp.kegg_medicus.v2023.2.Hs.symbols.gmt"))

# Perform fgsea with KEGG pathways
fgseaRes_kegg <- fgsea(pathwaysKEGG_MED, ranks)

# Organize and sort KEGG results by NES
fgseaResTidy_kegg <- fgseaRes_kegg %>%
  as_tibble() %>%
  arrange(desc(NES))

# Combine genes in leadingEdge with semicolons
fgseaResTidy_kegg$leadingEdge <- sapply(fgseaResTidy_kegg$leadingEdge, paste, collapse = ";")

# Show in a Tidy table of keg.
kable(fgseaResTidy_kegg) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

# Save fgseaRes_keg as txt file.
write.table(fgseaResTidy_kegg, file.path(output_dir, "pathway_analysis", "full_fgseaRes_kegRank.txt"), sep = "\t", row.names = FALSE, quote = FALSE)

# Mark "significant" if adjusted adj p-value <= 0.05, else "non-significant".
fgseaResTidy_kegg$adjPvalue <- ifelse(fgseaResTidy_kegg$padj <= 0.05, "significant", "non-significant")

# Create a ggplot of significant pathways, with bars colored based on adjusted p-value significance.
ggplot(fgseaResTidy_kegg[fgseaResTidy_kegg$padj < 0.05, ], aes(reorder(pathway, NES), NES, fill = adjPvalue)) + 
  geom_col() + 
  scale_fill_manual(values = cols) + 
  coord_flip() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(x = "Pathway", y = "Normalized Enrichment Score", title = "KEGG pathways NES Enrichment Score from GSEA")

# Plot significant pathways as points with a gradient color based on p-value and size based on a 'size' variable.
ggplot(fgseaResTidy_kegg[fgseaResTidy_kegg$padj < 0.05, ], aes(y=reorder(pathway, size),x= NES)) + geom_point(aes(color=padj,size=size)) + 
  scale_color_gradientn(colours = c("red","blue")) + 
  labs(x='Normalized Enrichment Score', y=NULL ) + 
  theme( axis.title = element_text(face='bold'), axis.text = element_text (face='bold') )
```
###### KEGG_LEGACY

```{r kegg_legacy, fig.width=9, fig.height=7}
# Load KEGG_MEDICUS pathways.
pathwaysKEGG_LEG <- gmtPathways(file.path(input_dir,"c2.cp.kegg_legacy.v2023.2.Hs.symbols.gmt"))

# Perform fgsea with KEGG pathways
fgseaResTidy_kegg_leg <- fgsea(pathwaysKEGG_LEG, ranks)

# Organize and sort KEGG results by NES
fgseaResTidy_kegg_leg <- fgseaResTidy_kegg_leg %>%
  as_tibble() %>%
  arrange(desc(NES))

# Combine genes in leadingEdge with semicolons
fgseaResTidy_kegg_leg$leadingEdge <- sapply(fgseaResTidy_kegg_leg$leadingEdge, paste, collapse = ";")

# Show in a Tidy table of keg.
kable(fgseaResTidy_kegg_leg) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

# Save fgseaRes_keg as txt file.
write.table(fgseaResTidy_kegg_leg, file.path(output_dir,"pathway_analysis","full_fgseaRes_KEGGRank_legacy.txt"), sep = "\t", row.names = FALSE, quote = FALSE)

# Plot significant pathways as points with a gradient color based on p-value and size based on a 'size' variable.
ggplot(fgseaResTidy_kegg_leg[fgseaResTidy_kegg_leg$padj < 0.05, ], aes(y=reorder(pathway, size),x= NES)) + geom_point(aes(color=padj,size=size)) + 
  scale_color_gradientn(colours = c("red","blue")) + 
  labs(x='Normalized Enrichment Score', y=NULL ) + 
  theme( axis.title = element_text(face='bold'), axis.text = element_text (face='bold') )
```

##### Over-Representation Analysis analysis (ORA)

To identifies whether certain gene sets are over-represented in a target gene group.

```{r ORA full toptable, fig.width=18, fig.height=12}
# Set a vector of differentially expressed genes for ORA
deGenes <- rownames(top.table)[top.table$adj.P.Val < 0.05]  # 5 genes

# Defining the gene universe as all genes considered in the analysis
geneUniverse <- rownames(expr_data)

## Performing ORA

# ORA for Hallmark pathways
oraHallmark <- fora(pathways = pathwaysH, genes = deGenes, universe = geneUniverse, minSize = 15, maxSize = 500)
oraHallmark$Pathway_Set <- "Hallmark"
oraHallmark$Significance <- ifelse(oraHallmark$padj < 0.05, "Significant", "Not Significant")

# ORA for KEGG_MEDICUS pathways
oraKeggMed <- fora(pathways = pathwaysKEGG_MED, genes = deGenes, universe = geneUniverse, minSize = 15, maxSize = 500)
oraKeggMed$Pathway_Set <- "KEGG_MEDICUS"
oraKeggMed$Significance <- ifelse(oraKeggMed$padj < 0.05, "Significant", "Not Significant")

# ORA for KEGG_LEGACY pathways
oraKeggLeg <- fora(pathways = pathwaysKEGG_LEG, genes = deGenes, universe = geneUniverse, minSize = 15, maxSize = 500)
oraKeggLeg$Pathway_Set <- "KEGG_LEGACY"
oraKeggLeg$Significance <- ifelse(oraKeggLeg$padj < 0.05, "Significant", "Not Significant")

# Display the top results for each pathway set
kable(oraHallmark, caption = "Hallmark Pathway Enrichment Results") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

kable(oraKeggMed, caption = "KEGG Medicus Pathway Enrichment Results") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  scroll_box(height = "400px")

DT::datatable(oraKeggLeg, 
              caption = htmltools::tags$caption("KEGG Legacy Pathway Enrichment Results"),
              options = list(pageLength = 10, scrollX = TRUE))

write.table(transform(oraHallmark, overlapGenes = sapply(overlapGenes, paste, collapse = ",")),
            file = file.path(output_dir, "pathway_analysis", "Hallmark_ORA_Results.csv"),
            sep = "\t", row.names = FALSE, quote = FALSE)

write.table(transform(oraKeggMed, overlapGenes = sapply(overlapGenes, paste, collapse = ",")),
            file = file.path(output_dir, "pathway_analysis", "KeggMed_ORA_Results.csv"),
            sep = "\t", row.names = FALSE, quote = FALSE)

write.table(transform(oraKeggLeg, overlapGenes = sapply(overlapGenes, paste, collapse = ",")),
            file = file.path(output_dir, "pathway_analysis", "KeggLeg_ORA_Results.csv"),
            sep = "\t", row.names = FALSE, quote = FALSE)

```

#### Enrichment Results by Treatment Subtype

##### GSEA + ORA + Visualizations

```{r GSEA + ORA + Visualizations}
# Define treatment groups
treatment_list <- c("chemo", "chemo+targeted", "IO+chemo", "targeted")

# Define helper functions for visualization
plot_gsea_outputs <- function(res, title_prefix) {
  res$adjPvalue <- ifelse(res$padj <= 0.05, "significant", "non-significant")
  cols <- c("non-significant" = "grey", "significant" = "red")

  # NES barplot
  print(ggplot(res, aes(reorder(pathway, NES), NES, fill = adjPvalue)) +
          geom_col() +
          scale_fill_manual(values = cols) +
          coord_flip() +
          labs(title = paste0(title_prefix, " - NES (GSEA)"),
               x = "Pathway", y = "NES") +
          theme(axis.text.y = element_text(size = 6),
                axis.title = element_text(face = 'bold')))

  # Dotplot
  print(ggplot(res[res$padj < 0.05, ], aes(y = reorder(pathway, size), x = NES)) +
          geom_point(aes(color = padj, size = size)) +
          scale_color_gradientn(colours = c("red", "blue")) +
          labs(title = paste0(title_prefix, " - Dotplot (GSEA)"),
               x = "NES", y = "Pathway") +
          theme(axis.text.y = element_text(size = 6),
                axis.title = element_text(face = 'bold')))
}

plot_ora_outputs <- function(res, title_prefix) {
  print(ggplot(res[res$padj < 0.05, ], aes(y = reorder(pathway, overlap), x = -log10(pval))) +
          geom_point(aes(color = padj, size = overlap)) +
          scale_color_gradientn(colours = c("red", "blue")) +
          labs(title = paste0(title_prefix, " - ORA Dotplot"),
               x = "-log10(p-value)", y = "Pathway") +
          theme(axis.text.y = element_text(size = 6),
                axis.title = element_text(face = 'bold')))
}

# Main loop
for (treatment in treatment_list) {
  cat("### Processing:", treatment, "\n")

  # Get top table and ranks
  top_table <- top_table_list[[treatment]]
  ranks <- setNames(top_table$logFC, top_table$Gene)
  ranks <- sort(ranks, decreasing = TRUE)
  deGenes <- rownames(top_table)[top_table$adj.P.Val < 0.05]
  geneUniverse <- rownames(expr_data)

  ## --- GSEA Hallmark ---
  gsea_h <- fgsea(pathwaysH, ranks) %>%
    as_tibble() %>%
    arrange(desc(NES)) %>%
    mutate(leadingEdge = sapply(leadingEdge, paste, collapse = ";"))
  write.table(gsea_h, file = file.path(output_dir, "pathway_analysis", paste0(treatment, "_fgsea_Hallmark.txt")),
              sep = "\t", row.names = FALSE, quote = FALSE)
  plot_gsea_outputs(gsea_h, paste("Hallmark", treatment))

  ## --- GSEA KEGG_MEDICUS ---
  gsea_med <- fgsea(pathwaysKEGG_MED, ranks) %>%
    as_tibble() %>%
    arrange(desc(NES)) %>%
    mutate(leadingEdge = sapply(leadingEdge, paste, collapse = ";"))
  write.table(gsea_med, file = file.path(output_dir, "pathway_analysis", paste0(treatment, "_fgsea_KEGG_Medicus.txt")),
              sep = "\t", row.names = FALSE, quote = FALSE)
  plot_gsea_outputs(gsea_med, paste("KEGG Medicus", treatment))

  ## --- GSEA KEGG_LEGACY ---
  gsea_leg <- fgsea(pathwaysKEGG_LEG, ranks) %>%
    as_tibble() %>%
    arrange(desc(NES)) %>%
    mutate(leadingEdge = sapply(leadingEdge, paste, collapse = ";"))
  write.table(gsea_leg, file = file.path(output_dir, "pathway_analysis", paste0(treatment, "_fgsea_KEGG_Legacy.txt")),
              sep = "\t", row.names = FALSE, quote = FALSE)
  plot_gsea_outputs(gsea_leg, paste("KEGG Legacy", treatment))

  ## --- ORA Hallmark ---
  ora_h <- fora(pathwaysH, genes = deGenes, universe = geneUniverse) %>%
    mutate(Pathway_Set = "Hallmark", 
           Significance = ifelse(padj < 0.05, "Significant", "Not Significant"),
           overlapGenes = sapply(overlapGenes, paste, collapse = ","))
  write.table(ora_h, file = file.path(output_dir, "pathway_analysis", paste0(treatment, "_ORA_Hallmark.txt")),
              sep = "\t", row.names = FALSE, quote = FALSE)
  plot_ora_outputs(ora_h, paste("Hallmark ORA", treatment))

  ## --- ORA KEGG_MEDICUS ---
  ora_med <- fora(pathwaysKEGG_MED, genes = deGenes, universe = geneUniverse) %>%
    mutate(Pathway_Set = "KEGG_MEDICUS",
           Significance = ifelse(padj < 0.05, "Significant", "Not Significant"),
           overlapGenes = sapply(overlapGenes, paste, collapse = ","))
  write.table(ora_med, file = file.path(output_dir, "pathway_analysis", paste0(treatment, "_ORA_KEGG_Medicus.txt")),
              sep = "\t", row.names = FALSE, quote = FALSE)
  plot_ora_outputs(ora_med, paste("KEGG Medicus ORA", treatment))

  ## pathwaysKEGG_MED ORA KEGG_LEGACY ---
  ora_leg <- fora(pathwaysKEGG_LEG, genes = deGenes, universe = geneUniverse) %>%
    mutate(Pathway_Set = "KEGG_LEGACY",
           Significance = ifelse(padj < 0.05, "Significant", "Not Significant"),
           overlapGenes = sapply(overlapGenes, paste, collapse = ","))
  write.table(ora_leg, file = file.path(output_dir, "pathway_analysis", paste0(treatment, "_ORA_KEGG_Legacy.txt")),
              sep = "\t", row.names = FALSE, quote = FALSE)
  plot_ora_outputs(ora_leg, paste("KEGG Legacy ORA", treatment))

  cat("âœ“ Finished:", treatment, "\n\n")
}
```

### 6. Correlation of Gene Features with Treatment Response

* Tool: [`PredictioR`](https://github.com/bhklab/PredictioR) R package
* Goal: identify individual gene-level associations with response status (R vs NR)


```{r Gnee corrolation with response}
```

### 7. Stratified PredictIO Signature Analysis

* Repeated **signature-based analysis** (Step 3) within subgroups
* Netx step: Grouped patients by **treatment arms** to detect treatment-specific associations

